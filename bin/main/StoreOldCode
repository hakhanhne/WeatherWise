package main;

import com.zeroc.Ice.Communicator;
import com.zeroc.Ice.Current;
import helper.PreferenceRequest;
import helper.SensorData;
import helper.User;
import org.junit.After;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.Parameterized;
import support.Preference;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.List;

import static org.junit.Assert.*;
import static org.junit.runners.Parameterized.*;


//@RunWith(Parameterized.class)
public class PreferenceRepositoryTest {

    private static PreferenceRepository.PreferenceWorkerI worker;
    private static List<Preference> preferences;
    private static PreferenceRepository repository;
    private static Communicator communicator;


    private String name;
    private static Current current;
    private PreferenceRequest request;
    private boolean bool;
    private List<Integer> tempThresholds = new ArrayList<>();


//    @Parameter(0)
//    public String username;
//    @Parameter(1)
//    public int medicalCondition;
//    @Parameter(2)
//    public int[] tempThreshholds;
    // no apoThreshhold, clock, sensorData, weather, apoReached, tempReached

//    public int[] tempThreshholds = new int[0];
//
//    public int apoThreshhold = 0;
//    public int clock = 0;
//    public SensorData sensorData = null;
//    public int weather = 0;
//    public boolean apoReached = false;
//    public boolean tempReached = false;

//    @Parameters
//    public static Collection<Object[]> data() {
//        // use Object, not any specific data type
//        Object[][] data = new Object[][]{{"Jack", 2}, {"David", 3}};
//        return Arrays.asList(data);
//    }

    @BeforeClass
    public static void beforeAllClass() throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {
        Method method = PreferenceRepository.class.getDeclaredMethod("readPreference", String.class, Integer.class);
        method.setAccessible(true);

    }
    @Test
    public void testReadPreference() throws Exception {
        // Mock the static private method
        mockStatic(YourClass.class);
        when(YourClass.class, "readPreference").thenReturn("mockedPreference");

        // Call the method you want to test
        String result = YourClass.someMethod();

        // Assert that the method returned the expected value
        assertEquals("expectedPreference", result);
    }
}


        // Mock the static fields of PreferenceRepository class
        try (MockedStatic<PreferenceRepository> preferenceRepoMock = Mockito.mockStatic(PreferenceRepository.class)) {
            preferenceRepoMock.when(() -> PreferenceRepository.main(new String[0])).thenReturn(preferences);

            // Create an instance of the PreferenceRepository.PreferenceWorkerI class
            PreferenceWorker preferenceWorker = new PreferenceRepository.PreferenceWorkerI();

            // Use reflection to call readPreference() and set it to accessible
//                Method readPreference = PreferenceRepository.class.getDeclaredMethod("readPreference");
//                readPreference.setAccessible(true);
//                Object preference = readPreference.invoke(null);

            // Call the getUserInfo() method with a name that matches a preference
            User result = preferenceWorker.getUserInfo("Jack", mock(Current.class));

            // Verify the result
            assert(result.medicalConditionType == expectedUserInfo.medicalConditionType);
            assert(result.tempThreshholds.length == expectedUserInfo.tempThreshholds.length);
            assert(result.tempThreshholds[0] == expectedUserInfo.tempThreshholds[0]);
            assert(result.tempThreshholds[1] == expectedUserInfo.tempThreshholds[1]);
        }


        // mock the readPreference method
                when(mockPreferenceRepository.readPreference()).thenReturn(preferences);